<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>基础设施 - 用 Rust 探索 Async</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="theme/pagetoc.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">简介</a></li><li class="chapter-item expanded "><a href="1_concurrent_vs_parallel.html"><strong aria-hidden="true">1.</strong> 并发 vs 并行</a></li><li class="chapter-item expanded "><a href="2_async_history.html"><strong aria-hidden="true">2.</strong> 异步的历史</a></li><li class="chapter-item expanded "><a href="3_0_the_operating_system.html"><strong aria-hidden="true">3.</strong> OS 与 CPU</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3_1_communicating_with_the_os.html"><strong aria-hidden="true">3.1.</strong> 与 OS 通信</a></li><li class="chapter-item expanded "><a href="3_2_cross_platform_abstractions.html"><strong aria-hidden="true">3.2.</strong> 跨平台抽象</a></li><li class="chapter-item expanded "><a href="3_3_the_cpu_and_the_os.html"><strong aria-hidden="true">3.3.</strong> CPU 与 OS</a></li></ol></li><li class="chapter-item expanded "><a href="4_interrupts_firmware_io.html"><strong aria-hidden="true">4.</strong> 中断 | 固件 | I/O</a></li><li class="chapter-item expanded "><a href="5_strategies_for_handling_io.html"><strong aria-hidden="true">5.</strong> 处理 I/O 的策略</a></li><li class="chapter-item expanded "><a href="6_epoll_kqueue_iocp.html"><strong aria-hidden="true">6.</strong> Epoll | Kqueue | IOCP</a></li><li class="chapter-item expanded "><a href="7_0_introducing_our_main_example.html"><strong aria-hidden="true">7.</strong> 例子简介</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="7_1_what_is_node.html"><strong aria-hidden="true">7.1.</strong> 什么是 Node</a></li><li class="chapter-item expanded "><a href="7_2_whats_our_plan.html"><strong aria-hidden="true">7.2.</strong> 接下来的计划</a></li></ol></li><li class="chapter-item expanded "><a href="8_0_implementing_our_own_runtime.html"><strong aria-hidden="true">8.</strong> 实现自己的运行时</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="8_1_the_main_loop.html"><strong aria-hidden="true">8.1.</strong> 主循环</a></li><li class="chapter-item expanded "><a href="8_2_setting_up_runtime.html"><strong aria-hidden="true">8.2.</strong> 设置 runtime</a></li><li class="chapter-item expanded "><a href="8_3_timers.html"><strong aria-hidden="true">8.3.</strong> Timers</a></li><li class="chapter-item expanded "><a href="8_4_callbacks.html"><strong aria-hidden="true">8.4.</strong> Callbacks</a></li><li class="chapter-item expanded "><a href="8_5_threadpool.html"><strong aria-hidden="true">8.5.</strong> Threadpool</a></li><li class="chapter-item expanded "><a href="8_6_io_eventqueue.html"><strong aria-hidden="true">8.6.</strong> I/O 事件队列</a></li><li class="chapter-item expanded "><a href="8_8_cleaning_up.html"><strong aria-hidden="true">8.7.</strong> 清理</a></li><li class="chapter-item expanded "><a href="8_9_infrastructure.html" class="active"><strong aria-hidden="true">8.8.</strong> 基础设施</a></li></ol></li><li class="chapter-item expanded "><a href="9_0_modules.html"><strong aria-hidden="true">9.</strong> 模块</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="9_1_file_module.html"><strong aria-hidden="true">9.1.</strong> 文件模块</a></li><li class="chapter-item expanded "><a href="9_2_crypto_module.html"><strong aria-hidden="true">9.2.</strong> 加密模块</a></li><li class="chapter-item expanded "><a href="9_3_http_module.html"><strong aria-hidden="true">9.3.</strong> Http 模块</a></li></ol></li><li class="chapter-item expanded "><a href="10_putting_pieces_together.html"><strong aria-hidden="true">10.</strong> 把代码组织起来</a></li><li class="chapter-item expanded "><a href="11_final_code.html"><strong aria-hidden="true">11.</strong> 最终代码</a></li><li class="chapter-item expanded "><a href="12_shortcuts_and_improvements.html"><strong aria-hidden="true">12.</strong> 捷径与改进</a></li><li class="chapter-item expanded affix "><a href="conclusion.html">总结</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">用 Rust 探索 Async</h1>

                    <div class="right-buttons">
                                                                        <a href="https://github.com/zjp-CN/exploring-async-basics-with-rust_zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <h1 id="infrastructure"><a class="header" href="#infrastructure">Infrastructure</a></h1>
<p>Now, for everything to work we need some helpers to make our infrastructure work.</p>
<p>First of all, we need a way to get the <code>id</code> of an available thread.</p>
<pre><code class="language-rust  ignored">   fn get_available_thread(&amp;mut self) -&gt; usize {
        match self.available_threads.pop() {
            Some(thread_id) =&gt; thread_id,
            // We would normally return None and not panic!
            None =&gt; panic!(&quot;Out of threads.&quot;),
        }
    }
</code></pre>
<p>As you see, we take one huge shortcut here. If we run out of threads, we <code>panic!</code>.
This is not good, and we should rather implement logic to queue these requests
and run them as soon as a thread is available. However, our code is already getting
long, and it's not very important for our goal of learning about <code>async</code>.</p>
<p>Maybe this implementing such a queue is a good reader-exercise? Feel free to fork
the repository and go ahead :)</p>
<p>The next thing we need to do is to create an unique identity for our callbacks.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// If we hit max we just wrap around
fn generate_identity(&amp;mut self) -&gt; usize {
    self.identity_token = self.identity_token.wrapping_add(1);
    self.identity_token
}

fn generate_cb_identity(&amp;mut self) -&gt; usize {
    let ident = self.generate_identity();
    let taken = self.callback_queue.contains_key(&amp;ident);

    // if there is a collision or the identity is already there, we loop until we
    // find a new one. We don't cover the case where there are `usize::max_value()`
    // callbacks waiting, since if we're fast and queue a new event
    // every nanosecond, that would still take 585 years on a 64 bit system.
    if !taken {
        ident
    } else {
        loop {
            let possible_ident = self.generate_identity();
            if self.callback_queue.contains_key(&amp;possible_ident) {
                break possible_ident;
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The function <code>generate_cb_identity</code> is where it all happens, <code>genereate_identity</code> is just
a small function so we try to avoid the long functions we had in the introduction.</p>
<blockquote>
<p>Now, there are some important considerations to be aware of. Even though we use
several threads, we use a regular <code>usize</code> here and the reason for that is that
it's only one thread that will be generating Id's. This could cause problems if
several threads tried to <code>read</code> and <code>generate</code> new Id's at the same time.</p>
</blockquote>
<p>We use the <code>wrapping_add</code> method on <code>usize</code> to get the next Id, this means that
when we reach <code>18446744073709551615</code> we wrap around to 0 again.</p>
<p>We do check of our callback_queue contains our key (even though that is unlikely
by design), and if it's taken we just generate a new one until we find a available
one.</p>
<p>Next up is the method we use to add a callback to our <code>callback_queue</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds a callback to the queue and returns the key
fn add_callback(&amp;mut self, ident: usize, cb: impl FnOnce(Js) + 'static) {
    let boxed_cb = Box::new(cb);
    self.callback_queue.insert(ident, boxed_cb);
}
<span class="boring">}
</span></code></pre></pre>
<p>If you haven't seen the signature <code>cb: impl FnOnce(Js) + 'static</code> before I'll
explain it briefly here.</p>
<p>The <code>impl ...</code> means that we accept an arguments that implements the trait <code>FnOnce(Js)</code>
with a <code>'static</code> lifetime. <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html">FnOnce</a> is
a trait implemented by <code>closures</code>. There are three main traits a <code>closure</code> can implement
in Rust and <code>FnOnce</code> is the one you'll use if you plan on consume an instance from
the environment.</p>
<p>Since you consume the variable a <code>closure</code> implementing <code>FnOnce</code> can only be called
once. Our closure will take ownership over resources we create in our <code>main</code> thread
and consume it. We want this since once consumed, the resources we used will be cleaned
up as a result of Rusts <code>RAII</code> pattern. It's implicit that <code>FnOnce</code> returns <code>()</code> in this
case so we don't have to write <code>FnOnce(Js) -&gt; ()</code>.</p>
<p>Since callbacks are meant to only be called once, this is a perfectly fine bound
for us to use here.</p>
<p>Now, traits doesn't have a size so for the compiler to be able to allocate space
for it on the stack we either need to take a reference <code>&amp;FnOnce(Js)</code> or place it
on the heap using <code>Box</code>. We do the latter since that's the only thing that makes
sense for our use case. Box is a pointer to a heap allocated variable which we do
know the size of so we store that reference in our <code>callback_queue</code> HashMap.</p>
<blockquote>
<p>What makes a closure?
A function in rust can be defined as easily as <code>|| { }</code>. If this is all we write
it's the same as a function pointer, equivalent to just referencing <code>my_method</code> (without parenthesis).
It becomes a <code>closure</code> as soon as you &quot;close&quot; over your environment by referencing
variables that's not owned by the <code>function</code>.</p>
<p><code>Fn</code> traits are automatically implemented, and whether it implements <code>Fn</code>, <code>FnMut</code>
or <code>FnOnce</code> depend whether you take ownership over a non-copy variable, take a shared
reference <code>&amp;</code> or an exclusive reference <code>&amp;mut</code> (often called a mutable reference).</p>
</blockquote>
<p>Now that we got some closure basics out of the way we can move on. The next method
is how we register <code>I/O</code> work. This is how we register an <code>epoll</code> event with our runtime:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn register_event_epoll(&amp;mut self, token: usize, cb: impl FnOnce(Js) + 'static) {
    self.add_callback(token, cb);

    print(format!(&quot;Event with id: {} registered.&quot;, token));
    self.pending_events += 1;
    self.epoll_pending_events += 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>The first thing we do is to add the callback to our <code>callback_queue</code>, calling the
method we explained previously. Next we do a print statement, just since we want
to print out the flow of our program we need to add this at strategic places.</p>
<blockquote>
<p>One important thing to note here. Our <code>token</code> in this case is already guaranteed
to be unique. We generate it in the <code>Http</code> module (which is the only one registering
events by using this method in our example). The reason for this will become clear
in a few short chapters. Just note that we don't need to call <code>generate_cb_identity</code> here.</p>
</blockquote>
<p>We increase the counters on both <code>pending_events</code> and <code>epoll_pending_events</code>.</p>
<p>Our next method registers work for the thread pool</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn register_event_threadpool(
    &amp;mut self,
    task: impl Fn() -&gt; Js + Send + 'static,
    kind: ThreadPoolTaskKind,
    cb: impl FnOnce(Js) + 'static,
) {
    let callback_id = self.generate_cb_identity();
    self.add_callback(callback_id, cb);

    let event = Task {
        task: Box::new(task),
        callback_id,
        kind,
    };

    // we are not going to implement a real scheduler here, just a LIFO queue
    let available = self.get_available_thread();
    self.thread_pool[available].sender.send(event).expect(&quot;register work&quot;);
    self.pending_events += 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's first have a look at the arguments to this function (aside from <code>&amp;mut self</code>).</p>
<p><code>task: impl Fn() -&gt; Js + Send + 'static</code> is a task we want to run on a separate
thread. This closure has the bond: <code>Fn() -&gt; Js + Send + 'static</code> which means
it's a <code>closure</code> that takes no arguments, but returns a type of <code>Js</code>. It needs to
be <code>Send</code> since we're sending this task to another thread.</p>
<p><code>kind: ThreadPoolTaskKind</code> lets us know what kind of task this. We do this for
two reasons:</p>
<ol>
<li>We need to be able to signal a <code>Close</code> event to our threads</li>
<li>We want to be able to print the kind of task each event received.</li>
</ol>
<p>As you understand, we don't have to create a <code>Kind</code> for every task, but since we
want to print out what the thread received we need some way of judging what kind
of task each thread received.</p>
<p>The last argument <code>cb: impl FnOnce(Js) + 'static</code> is our callback. It's not a coincidence
that our <code>task</code> returns a type of <code>Js</code> and our callback takes a <code>Js</code> as an argument. The
result of the work we do in our thread is the input to our callback. This closure doesn't
need to be <code>Send</code> since we don't pass the callback itself to the thread pool.</p>
<p>Next we generate a new identity with <code>self.generate_cb_identity()</code> and we add the
callback to our callback queue.</p>
<p>Then we construct a new <code>Event</code>, and as I have shown earlier, we need to <code>Box</code> the
closure.</p>
<p>Now, the last part could be made arbitrarily complex. This is where you decide how
you want to schedule your work to the thread pool. In our case we just get an
available thread (and <code>panic!</code> if we're out of thread - ouch), and we send our task
to the thread which then runs it until it's finished.</p>
<p>You could make priorities based on <code>TaskKind</code>, you could try to decide which tasks
are short and which are long and prioritize them based on load. A lot of exciting
things could be done here. We will choose the simplest possible one though, and just
push them directly to a thread in the order they come.</p>
<p>The last part of the &quot;infrastructure&quot; is a function to set a timeout.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn set_timeout(&amp;mut self, ms: u64, cb: impl Fn(Js) + 'static) {
        // Is it theoretically possible to get two equal instants? If so we'll have a bug...
        let now = Instant::now();
        let cb_id = self.generate_cb_identity();
        self.add_callback(cb_id, cb);
        let timeout = now + Duration::from_millis(ms);
        self.timers.insert(timeout, cb_id);
        self.pending_events += 1;
        print(format!(&quot;Registered timer event id: {}&quot;, cb_id));
    }
<span class="boring">}
</span></code></pre></pre>
<p>Set timeout uses <code>std::time::Instant</code> to get a representation of &quot;now&quot;. It's the first
thing we do since the user expects the timeout to be calculated from &quot;now&quot;, and some
of our operations here might take a little time.</p>
<p>We generate an identity for the callback <code>cb</code> passed in to <code>set_timeout</code> and add
that callback to our callback queue.</p>
<p>We add the <code>duration</code> in milliseconds to our <code>Instant</code> so we know at what time
our timeout times out.</p>
<p>We insert the <code>callback_id</code> instant to our <code>BtreeMap</code> with the calculated <code>Instant</code> as
the key.</p>
<p>We increase the counter for <code>pending_events</code> and print out a message for us to
be able to follow the flow of our program.</p>
<blockquote>
<p>This might be a good time to talk briefly about our choice of a <code>BTreeMap</code> as
the collection we store timers in.</p>
<p>From the documentation we can read <em>&quot;In theory, a binary search tree (BST) is the optimal choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of comparisons necessary to find an element (log2n).&quot;</em>
Now, this isn't a Binary Tree but a BTree. While a BST allocates one node for each value, a BTree allocates
a small <code>Vec</code> of values for each node. Modern computers reads much more data than we normally ask for
into its caches, and thats one reason they love contiguous parts of memory. A BTree will result in
a more optimal &quot;cache efficiency&quot; which often trumps the gains of the theoretically more optimal
algorithm in a true BST.</p>
<p>Lastly, since we're talking about searching sorted collections here, and timeouts, is a perfect example
of such, we'll of course use this when it's so readily available to us in Rusts standard library.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="8_8_cleaning_up.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="9_0_modules.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="8_8_cleaning_up.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="9_0_modules.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
                <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-149686420-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
                <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="theme/pagetoc.js"></script>
        
        
    </body>
</html>
