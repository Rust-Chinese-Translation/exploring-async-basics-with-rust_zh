# OS

在程序员做的所有事情中，OS 都处于中心地位，除非你[写 OS] ，或者在[嵌入式领域]。
所以无论如何都不能抛开一些 OS 细节谈任何编程基础。

[写 OS]: https://os.phil-opp.com/
[嵌入式领域]: https://rust-embedded.github.io/book/

## 从 OS 角度看并发

<div style="color: back;  font-style: italic; font-size: 1.2em">
“操作系统自 1990s 以来就 ‘假装 ’ 以同步方式执行。”
</div>

这联系起第一章说到的，谈并发需要依照[参照系]，而且我解释了 OS 可能在任何时候停止再开始进程。

大多数情况下，所谓的同步式 (synchronous) 代码是对程序员而言看似同步的代码。
OS 或 CPU 都不是完全同步式的。

OS 采用抢占式多任务处理 ([preemptive multitasking]) ，只要你所运行的 OS 正在抢占式调度进程，
那么你就无法保证你的代码不被中断地逐条指令地运行。

OS 会确保所有重要的线程从 CPU 获取时间再进行下去。

> 在有 4/5/8/12 个物理核的现代机器上，情况也不是如此简单，
> 因为你的机器实际可能在很少负荷的时候把代码放到一个 CPU 上不中断地执行完。
> 这里讨论的重点是：你无法确切地知道到底会发生什么情况，也不能保证你的代码不被中断地执行。

[参照系]: ./1_concurrent_vs_parallel.md#转换参照系
[preemptive multitasking]: ./2_async_history.md#抢占式多任务处理

## 与 OS 合作

当我们在乎效率时，时常忘了编程需要把多少零部件组装起来。
你发出一个网络请求时，并不是要求 CPU 或者网卡做什么，而是要求 OS 为你转告网卡做什么。

你无法在不发挥 OS 优势的情况下让程序最高效地运行。你基本上无权直接操作硬件。

可是，这也意味着若从根本上理解所有事情，你还需要知道你的 OS 如何处理这些任务。

为了能与 OS 工作，我们得了解如何与交流（通信），这就是接下来要谈到的话题了。

